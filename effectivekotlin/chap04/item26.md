# item26. 함수 내부의 추상화 레벨을 통일하라.
컴퓨터는 복잡한 장치이지만 복잡함이 여러 계층에 다양한 요소로 분할 되어 있어서 쉽게 사용할 수 있다.  
개발자에게 컴퓨터에서의 가장 낮은 추상화 계층은 하드웨어이다. 그 다음은 프로세서 제어 명령이다. 
이는 0과 1로 이루어 지지만 어셈블리라는 언어로 표현되어 쉽게 읽을 수 있다. 
하지만 이 또한 굉장히 어려우므로 프로그래밍을 간단히 할 수 있게 하나의 언어를 낮은 레벨의 언어로 변환하는 컴파일러를 만들었다.
이렇게 반복되면서 더 나은 프로그래밍언어들이 탄생했다.  

계층이 잘 분리 되면 그 계층에서 작업할 때 다른 계층은 생각할 필요가 없다. 어셈블리 언어, JVM 바이트 코드가 무엇인지 몰라도 프로그래밍할 수 있는 것이다.

## 추상화 레벨
높은 레벨로 갈수록 물리장치로 부터 멀어고, 걱정해야 하는 세부적인 내용들이 적어진다. 하지만, 높은 레벨로 갈수록 제어력이 떨어진다.  
C언어는 메모리 관리를 직접 할 수 있지만, 자바는 가비지 컬렉터가 자동으로 메모리 관리를 해 메모리 사용을 최적화 하는 것이 힘들다. 

## 추상화 레벨 통일
컴퓨터 과학과 마찬가지로 코드도 추상화를 계층처럼 만들어 사용할 수 있다. 이를 위한 기본적인 도구가 함수이다. 
> 추상화 레벨 통일 원칙 (Single Level of Abstraction, SLA)
> 높은 레벨과 낮은 레벨을 구분해서 사용해야한다.

버튼 하나만 누르면 커피를 만들 수 있는 커피 머신을 만든다고 해보자.
```kotlin
class CoffeeMachine {
    fun makeCoffee() {
        // 수백 개의 변수를 선언한다.
        // 복잡한 로직을 처리한다.
        // 낮은 수준의 최적화도 여기서 한다.
    }
}
```
위와 같이 코드를 작성하면 makeCoffee()는 수백 줄이 될 수도 있다. 이런 함수는 읽으면서 세부적인 내용을 신경써야 하므로 읽고 이해하는 것이 힘들다.
그래서 다음과 같이 함수를 계층 처럼 나누어 사용하는 것이 좋다.
```kotlin
class CoffeeMachine {
    fun makeCoffee() {
        boilWater()
        brewCoffee()
        pourCoffee()
        pourMilk()
    }
    
    private fun boilWater() { }
    private fun brewCoffee() { }
    private fun pourCoffee() { }
    private fun pourMilk() { }
}
```
이제 이 함수가 어떻게 동작하는지 확실히 알 수 있다. 매우 간단한 추상화를 추출해 가독성을 크게 향상 시킨 것이다.   
이처럼 함수는 간단해야 한다. **함수는 작아야 하며, 최소한의 책임만 가져야 한다.**  
추가로, 이런 형태로 함수를 추출하면 재사용과 테스트가 쉬워진다. 

## 프로그램 아키택처의 추상 레벨
추상화 계층 개념은 함수보다 높은 레벨에서도 적용할 수 있다. 
추상화를 구분을 통해 서브시스템의 세부 사항을 숨기고 상호운영성과 플랫폼 독립성을 얻을 수 있다. 
이는 문제 중심으로 프로그래밍한다는 의미이다.   
eg)
* 4 -> 높은 레벨 문제 중심
* 3 -> 낮은 레벨 문제 중심
* 2 -> 낮은 레벨 구현 구조
* 1 -> 프로그래밍 언어 구조와 도구
* 0 -> 운영 체제 연산과 머신 명령  

이러한 개념은 모듈 시스템을 설계할 떄도 중요하다. 모듈을 분리하면 계층 고요의 요소를 숨길수 있다. 
* 낮은 레벨: 입력과 출력을 나타내는 모듈
* 높은 레벨: 비즈니스 로직을 나타내는 부분

계층이 잘 분리된 프로젝트를 계층화가 잘 되었다고 한다. 계층화가 잘 된 프로젝트는 어떤 계층 위치에서 보아도 일관적인 관점을 얻을 수 있다.


